\documentclass[11pt,twoside,a4paper]{article}

%% BibTeX settings
\usepackage[authoryear,round]{natbib}

%% additional packages
\usepackage[latin1]{inputenc}
\usepackage{a4wide,graphicx,color,thumbpdf}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{url}

% hyperref setup
\definecolor{Red}{rgb}{0.5,0,0}
\definecolor{Blue}{rgb}{0,0,0.5}
\hypersetup{%
  pdftitle = {Lesson 4},
  pdfsubject = {},
  pdfkeywords = {},
  pdfauthor = {},
  %% change colorlinks to false for pretty printing
  colorlinks = {true},
  linkcolor = {Blue},
  citecolor = {Blue},
  urlcolor = {Red},
  hyperindex = {true},
  linktocpage = {true},
}

\usepackage{Sweave} %% is essential

\begin{document}
\SweaveOpts{concordance=TRUE}

\title{Handling spatial vector data in R}
\author{Sytze de Bruin}

\maketitle

\section{Today's learning objectives}
In today's lecture, we will explore the basics of handling spatial vector data in R. There are several R packages for this purpose but we will focus on using \texttt{sp}, \texttt{rgdal}, \texttt{rgeos} and some  related packages. At the end of the lecture, you should be able to
\begin{enumerate}
  \item create point, line and polygon objects from scratch;
  \item explore the structure of \texttt{sp} classes for spatial data;
  \item transform between datums and map projections; 
  \item apply basic operations on vector data, such as buffering, intersection and area calculation;
  \item use a Date-Time class;
  \item write spatial data to a kml file.
  \item convert spatial data read from a plain text file into a spatial class.
\end{enumerate}

\section{Some packages for working with spatial vector data in R}

The packages \texttt{sp} and \texttt{rgdal} are widely used throughout this course. Both packages not only provide functionallity for raster data but also for vector data. For example, rgdal includes bindings to parts of the OGR Simple Feature Library which provides access to a variety of vector file formats such as ESRI Shapefiles and kml. Similarly, rgeos is an interface to the powerful Geometry Engine  Open Source (GEOS) library for all kind of operations on geometries (buffering, overlaying, area calculations, etc.).  Thus, functionality that you commonly find in expensive GIS software is also available within R, using free but very powerful software libaries. The possiblities are huge; in this course we can only scratch the surface with some essentials which hopefully invite you to experiment further and use them in your research. Details can be found in the book Applied Spatial Data Analysis with R and several vignettes authored by Roger Bivand, Edzer Pebesma and Virgilio Gomez-Rubio \citep{Bivand:2013ux}. Owing to time constraints, this lecture cannot cover the related package spacetime with classes and methods for spatio-temporal data.

\section{Creating basic geometries}

The package \texttt{sp} provides classes for spatial-only geometries, such as \texttt{SpatialPoints} (for points), and combinations of geometries and attribute data, such as a \texttt{SpatialPointsDataFrame}. The following data classes are available for spatial vector data \citep{Edzer:2005ux}:


\begin{center}
\begin{tabular}{lllll}
data type & class                        & attributes  \\ \hline
points    & {\tt SpatialPoints}          & No \\
points    & {\tt SpatialPointsDataFrame} & {\tt data.frame} \\
line      & {\tt Line}                   & No  \\
lines     & {\tt Lines}                  & No  \\
lines     & {\tt SpatialLines}           & No  \\
lines     & {\tt SpatialLinesDataFrame}  & {\tt data.frame} \\
rings     & {\tt Polygon}                & No  \\
rings     & {\tt Polygons}               & No  \\
rings     & {\tt SpatialPolygons}        & No  \\
rings     & {\tt SpatialPolygonsDataFrame} & {\tt data.frame} \\
\end{tabular}
\end{center}

We will go through a few examples of creating geometries from scratch to familiarize yourself with these classes. First, start Google Earth on your computer and make a note of the longitude and latitude of two points in Wageningen that are relevant to you. Use a decimal degree notation with at least 4 digits after the decimal point. To change the settings in Google Earth click \texttt{Tools | Options} and change the Show lat/Long setting on the 3D View Tab. 

\subsection*{Points}
The example below shows how you can create spatial point objects from these coordinates.

<<>>=
# load sp package
library(sp)

# coordinates of two points identiefied in Google Earth, for example
pnt1_xy <- cbind(5.6660, 51.9872)   # enter your own coordinates
pnt2_xy <- cbind(5.6643, 51.9668)   # enter your own coordinates
# combine coordinates in single matrix
coords <- rbind(pnt1_xy, pnt2_xy)

# make spatial points object
prj_string_WGS <- CRS("+proj=longlat +datum=WGS84")
mypoints <- SpatialPoints(coords, proj4string=prj_string_WGS)
@

<<eval=FALSE>>=
# inspect object
class(mypoints)
str(mypoints)
@

<<eval=TRUE, fig=FALSE>>=
# create and display some attribute data and store in a data frame
mydata <- data.frame(cbind(id = c(1,2), 
                Name = c("my description 1", 
                         "my description 2")))

# make spatial points data frame
mypointsdf <- SpatialPointsDataFrame(
  coords, data = mydata, 
  proj4string=prj_string_WGS)
@

<<eval=FALSE, fig=FALSE>>=
class(mypointsdf) # inspect and plot object
names(mypointsdf)
str(mypointsdf)
spplot(mypointsdf, zcol="Name", col.regions = c("red", "blue"), 
       xlim = bbox(mypointsdf)[1, ]+c(-0.01,0.01), 
       ylim = bbox(mypointsdf)[2, ]+c(-0.01,0.01),
       scales= list(draw = TRUE))
@


Notice the difference between the objects mypoints and mypointsdf.

\subsection*{Lines}
Now let us connect the two points by a straight line. First find information on the classes for lines that are available in \texttt{sp}. The goal is to create SpatialLinesDataFrame but we have to go through some other classes.

<<>>=
# first consult help SpatialLines
simple_line <- Line(coords)
lines_obj <- Lines(list(simple_line), "1")
spatlines <- SpatialLines(list(lines_obj), proj4string=prj_string_WGS)
line_data <- data.frame(Name = "straight line", row.names="1")
mylinesdf <- SpatialLinesDataFrame(spatlines, line_data)
@

<<eval=FALSE, fig=FALSE>>=
class(mylinesdf)
str(mylinesdf)
spplot(mylinesdf, col.regions = "blue", 
       xlim = bbox(mypointsdf)[1, ]+c(-0.01,0.01), 
       ylim = bbox(mypointsdf)[2, ]+c(-0.01,0.01),
       scales= list(draw = TRUE))
@

Try to understand the above code and results by studying help.

\subsection*{Writing and reading spatial vector data using OGR}
What now follows is a brief intermezzo before continuing with the classess for polygons. Let us first export the objects created thusfar to kml files that can be displayed in Google Earth. We will use OGR functionality for that purpose, which is available through the package \texttt{rgdal}.

% <<>>=
% library(rgdal)
% # write to kml ; below we that there is a subdirectory data within the current 
% # working directory.
% writeOGR(mypointsdf, "data/mypointsGE.kml", "mypointsGE", driver="KML", overwrite_layer=T)
% writeOGR(mylinesdf, "data/mylinesGE.kml", "mylinesGE", driver="KML", overwrite_layer=T)
% @

% Check whether the attribute data were written to the kml output.
% 
% The function \texttt{readOGR} allows reading OGR compatible data into a suitable Spatial vector object. Similar to \texttt{writeOGR}, the function requires entries for the arguments dsn (data source name) and layer (layer name). The interpretation of these enties vary by driver. Please study details in the help file.
% Digitize a path (e.g. a bicycle route) between the two points of interest you selected earlier in Google Earth. This can be achieved using the \texttt{Add Path} functionality. Save the path in the data folder within the working directory under the name \texttt{route.kml}. We will read this file into a spatial lines object and add it to the already existing \texttt{SpatialLinesDataFrame} object.
% 
% <<>>=
% myroute <- readOGR("data/route.kml", "route.kml")
% # put both in single data frame
% myroute@proj4string <- prj_string_WGS
% names(myroute)
% myroute$Description <- NULL
% mylinesdf <- rbind(mylinesdf, myroute)
% @
% 
% Try to understand the above code and results. Feel free to display the data and export to Google Earth.
% 
% \subsection*{Transformations between projections}
% Transformations between coordinate systems are crucial to many GIS applications. In some of the examples below we will use metric distances whereas the data we have used so far used a polar coordinate system. One way to deal with this is by transforming the data to a planar coordinate system. In R this can be achieved via bindings to the PROJ.4 - Cartographic Projections Library (\url{http://trac.osgeo.org/proj/}), which are available in \texttt{rgdal}. We will transform our spatial data to the Dutch grid (Rijksdriehoekstelsel) often referred to as RD. 
% Note that: 
% \begin{itemize}
%   \item some widely spread definitions of the Dutch grid (EPSG: 28992) are incomplete;
%   \item the transformation used below is approximate since it does not account for time dependent differences between WGGS84 and ETRS89 and it does not apply a correction grid for modelling errors in the original measurements of RD. Details can be found at \url{http://nl.wikipedia.org/wiki/Rijksdriehoekscoordinaten}.
% \end{itemize}
% 
% <<>>=
% # define CRS object for RD projection (find help)
% prj_string_RD <- CRS("+proj=sterea +lat_0=52.15616055555555 +lon_0=5.38763888888889 
% +k=0.9999079 +x_0=155000 +y_0=463000 +ellps=bessel +towgs84=565.2369,50.0087,465.658,
% -0.406857330322398,0.350732676542563,-1.8703473836068,4.0812 +units=m +no_defs")
% 
% # perform the coordinate transformation from WGS84 to RD
% mylinesRD <- spTransform(mylinesdf, prj_string_RD)
% 
% # add length attribute to lines object
% library(rgeos)
% mylinesdf$length <- gLength(mylinesRD, byid=T)
% mylinesdf@data
% 
% @
% 
% \begin{itemize}
%   \item some item
%   \item some other item
%   \begin{itemize}
%     \item some sub item
%     \item next sub item
%   \end{itemize}
% \end{itemize}
%   
% 
% % this chunk runs silently
% <<echo = FALSE, results = hide, eval=FALSE>>=
% library(sp)
% a <- 1
% @
% % the following is just for show
% \begin{Sinput}
% > setwd('path/to/rasta/package') # set this to the appropriate directory
% \end{Sinput}
% <<>>=
% @



\bibliographystyle{model5-names}
\bibliography{refs}

\end{document}
